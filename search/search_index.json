{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Goiabada","text":"<p>Goiabada is an open-source authentication and authorization server. </p> <p>Goiabada provides a solution for user management, allowing application developers to define users, groups, resources and permissions within their software. It also allows the authentication and authorization of server-to-server interactions.</p> <ul> <li>Written in Go for speed and minimal resource consumption (container image size &lt; 35 MB)</li> <li>User-friendly interface</li> <li>Support for single sign on (SSO)</li> <li>2 factor authentication support with one-time password (OTP)</li> <li>Granular control over resources and permissions, for effective authorization</li> <li>Self-service account page enabling users to modify personal and security details</li> <li>OAuth2 support, including authorization code flow and client credentials flow</li> <li>OpenID Connect support</li> </ul>"},{"location":"#screenshots","title":"Screenshots","text":""},{"location":"about/","title":"About","text":"<p>I developed Goiabada with the aim of creating a user management container that blends simplicity with efficiency.</p> <p>While plenty of alternatives exist, some paid, others open source, I felt there was room to build an auth server intuitive for developers of all levels, giving my own personal expression.</p> <p>I'm committed to make Goiabada forever free and open source, to benefit the community. You can self host it and have total control over the code and data.</p> <p>The name is inspired by a Brazilian sweet made with guava. I was also keen on choosing a word that started with Go \ud83d\ude09</p> <p></p> <p>Don't hesitate to contact me at contact@leodip.com, or consider visiting my blog or LinkedIn profile.</p> <p>Leonardo D'Ippolito</p>"},{"location":"customizations/","title":"Customize","text":""},{"location":"customizations/#app-name-issuer-and-ui-theme","title":"App name, issuer and UI theme","text":"<p>The most basic level of customization is to set the app name, issuer (the same as the public deployment URL) and also choosing a UI theme. Those things should be customized in the admin area, using the web interface.</p>"},{"location":"customizations/#html-templates","title":"HTML templates","text":"<p>You can also modify any HTML template of Goiabada, if you wish, provided you don't break the existing UI code (the javascript sections, element ids, etc.). You need to be careful and know what you're doing.</p> <p>The overall strategy is:</p> <ol> <li>copy the <code>web</code> folder from container to host</li> <li>make your modifications in the HTML/CSS files</li> <li>relaunch the Goiabada container with a volume, mapping from host folder to container folder.</li> </ol> <p>Example:</p> <pre><code>docker ps -a\n</code></pre> <p>This will list all containers - make a note of the Goiabada container ID. For example: <code>39ae6e1b54aa</code>. Then:</p> <pre><code>docker cp 39ae6e1b54aa:/app/web ./web\n</code></pre> <p>Now you have the <code>web</code> folder on your host, with all the HTML resources. You can change the HTML/CSS files as you want.</p> <p>Now you need to relaunch the containers with a volume. You can add this to your <code>docker-compose.yml</code> (example):</p> Add the volume<pre><code>(...)\ndepends_on: \n  mysql-server:\n    condition: service_healthy  \nvolumes:\n  - ./web:/app/web\ncommand: sleep infinity\n(...)\n</code></pre>"},{"location":"customizations/#tailwind-css","title":"Tailwind CSS","text":"<p>Goiabada uses Tailwind CSS. When customizing the templates you can add/change Tailwind CSS classes if you wish. However, if you do that, it's necessary that you run the Tailwind CLI tool, after you finish editing the files. The Tailwind CLI tool will regenerate the file <code>main.css</code> that is used by the application.</p> <p>You can download the Tailwind CLI tool here: https://tailwindcss.com/blog/standalone-cli.</p> <p>Here's how you can regenerate the <code>main.css</code> file:</p> <pre><code>(the current folder here is one level up the web folder)\n\ntailwindcss -c ./web/tailwindcss/tailwind.config.js -i ./web/tailwindcss/input.css -o ./web/static/main.css\n</code></pre>"},{"location":"development/","title":"Development","text":"<p>Goibada was developed in Go using Fedora Linux (\u2764\ufe0f). The github repository has a vscode <code>devcontainer</code> with all the dependencies configured to run Goiabada locally. </p> <p>To get started, simply clone the repository, open it in the <code>devcontainer</code>, start it by using the <code>make serve</code> command.</p> <p>For running integration tests, first use the <code>make serve</code> command to start the web server, then in another terminal use the <code>make test</code> script. Test coverage will be progressively improved over time.</p> <p>Goiabada uses go-sqlbuilder for SQL generation, Tailwind CSS with DaisyUI for UI &amp; styling, and the chi router to manage the incoming HTTP requests.</p> <p>Pull requests are encouraged. You can reach out to me at contact@leodip.com. Your involvement is welcome and appreciated.</p>"},{"location":"envvars/","title":"Environment variables","text":"<p>Goiabada uses environment variables to configure the application. </p> <p>The following table lists the environment variables and their default values:</p>"},{"location":"envvars/#general-settings","title":"General settings","text":"Name Description Default value <code>GOIABADA_APPNAME</code> The name of the application <code>Goiabada</code> <code>GOIABADA_ADMIN_EMAIL</code> The email address of the admin user (the first user created) <code>admin@example.com</code> <code>GOIABADA_ADMIN_PASSWORD</code> The password of the admin user (the first user created) <code>changeme</code>"},{"location":"envvars/#http-listener-settings","title":"HTTP listener settings","text":"Name Description Default value <code>GOIABADA_KEYFILE</code> PKCS8 key file for https.If empty, TLS will not be enabled. empty <code>GOIABADA_CERTFILE</code> Certificate file for https.If empty, TLS will not be enabled. empty <code>GOIABADA_HOST</code> Server's hostname. The empty string will make it listen on all network interfaces. <code>localhost</code> if not in a container, or empty string if in a container. <code>GOIABADA_PORT</code> Server's TCP port.If empty and TLS enabled: <code>8443</code>, otherwise <code>8080</code>. <code>8080</code> (http) or <code>8443</code> (https) <code>GOIABADA_BASEURL</code> Server's external URL.If empty, calculated from TLS enabled state, <code>GOIABADA_HOST</code> and <code>GOIABADA_PORT</code> <code>http://localhost:8080</code> <code>GOIABADA_ISSUER</code> Value of <code>iss</code> field in the generated JWT tokens.If empty, equals to the <code>GOIABADA_BASEURL</code> <code>http://localhost:8080</code> <code>GOIABADA_STATICDIR</code> The directory where the static files are located.If empty, uses the static files embedded into the binary. empty <code>GOIABADA_TEMPLATEDIR</code> The directory where the HTML templates are located.If empty, uses the HTML templates embedded into the binary. empty <code>GOIABADA_ISBEHINDAREVERSEPROXY</code> If you want to use a reverse proxy in front of Goiabada, set this to <code>true</code> <code>false</code> <code>GOIABADA_RATELIMITER_ENABLED</code> An HTTP rate limiter is available to prevent brute force attacks. It's enabled by default. Some users prefer to apply an HTTP rate limiter from an external service like Cloudflare. If that's you, set this to <code>false</code>. <code>true</code> <code>GOIABADA_RATELIMITER_MAXREQUESTS</code> The maximum number of requests allowed per time window.Only relevant if the http rate limiter is enabled. <code>50</code> <code>GOIABADA_RATELIMITER_WINDOWSIZEINSECONDS</code> The rate limiter window size in seconds.Only relevant if the http rate limiter is enabled. <code>10</code>"},{"location":"envvars/#database-settings","title":"Database settings","text":"Name Description Deafult value <code>GOIABADA_DB_TYPE</code> Currently <code>mysql</code> and <code>sqlite</code> are supported.For backward compatibility, the default value is <code>mysql</code>, but if <code>GOIABADA_DB_HOST</code> isn't defined, then the default is <code>sqlite</code>. <code>mysql</code> <code>GOIABADA_DB_HOST</code> DB server hostname. <code>localhost</code> <code>GOIABADA_DB_PORT</code> DB server TCP port. <code>3306</code> <code>GOIABADA_DB_USERNAME</code> DB user's name. <code>root</code> <code>GOIABADA_DB_PASSWORD</code> DB user's password. empty <code>GOIABADA_DB_DBNAME</code> Database (schema) name. <code>goiabada</code> <code>GOIABADA_DB_DSN</code> DSN of the database. Only applicable when db type is <code>sqlite</code>.When using a file, don't forget to add <code>?_pragma=busy_timeout=5000&amp;_pragma=journal_mode=WAL</code> (see example on the right). <code>file::memory:?cache=shared</code>or<code>file:/home/john/goiabada.db?_pragma=busy_timeout=5000&amp;_pragma=journal_mode=WAL</code>"},{"location":"envvars/#log-settings","title":"Log settings","text":"Name Description Default value <code>GOIABADA_LOGGER_ROUTER_HTTPREQUESTS_ENABLED</code> If <code>true</code>, log the HTTP requests. <code>false</code> <code>GOIABADA_AUDITING_CONSOLELOG_ENABLED</code> If <code>true</code>, log audit messages to console. <code>false</code> <code>GOIABADA_LOGGER_GORM_TRACEALL</code> If <code>true</code>, log all SQL statements to console. <code>false</code> <p>When starting Goiabada without any environment variable set, it will listen on <code>http://localhost:8080</code> and will use an in-memory SQLite database. </p> <p>The admin email and password will be <code>admin@example.com</code> and <code>changeme</code>. All changes will be lost upon restart. If you want a permanent test environment, specify the <code>GOIABADA_DB_DSN</code> = <code>file:./goiabada.db</code> environment variable.</p>"},{"location":"how-it-works/","title":"How it works","text":""},{"location":"how-it-works/#use-cases","title":"Use cases","text":"<p>Goiabada comes in handy in two main situations:</p> <ol> <li>When you have users who need to access a resource (an area of your application, or an API)</li> <li>When you have a server that wants to access another server securely</li> </ol> <p>Let's view those in more details.</p>"},{"location":"how-it-works/#users-accessing-resources","title":"Users accessing resources","text":"<p>When you have users accessing resources, you basically need to know: who is the user (authentication), and if they're allowed to access that resource (authorization).</p> <p>Goiabada works with two familiar web protocols to fulfil that: OpenID Connect handles the who's who (authentication), and OAuth2 takes care of who can do what (authorization).</p> <p>When users are accessing resources, no matter what type of app you may have (like a web app on the server side, a web app using JavaScript, or a mobile native app), the recommended way to go is the Authorization code flow with PKCE.</p> <p>The Authorization code flow with PKCE is a secure method for user authentication in web applications. It involves a two-step process: first, the application requests an authorization code in the <code>/authorize</code> endpoint, and then it exchanges this code for an access token, a refresh token, and optionally an id token, using the <code>/token</code> endpoint.</p> <p>PKCE adds an extra layer of security by preventing interception of the authorization code, particularly in public clients like mobile or single-page applications.</p>"},{"location":"how-it-works/#server-to-server-communications","title":"Server to server communications","text":"<p>When you have a set of servers working together, and you want to ensure that only the right clients can access resources on a specific server, go for the Client credentials flow, with a confidential client.</p>"},{"location":"how-it-works/#learn-more-about-oauth2","title":"Learn more about OAuth2","text":"<p>OAuth2 covers a lot of ground. To delve deeper into it, check out this link - https://www.oauth.com/</p>"},{"location":"how-it-works/#clients","title":"Clients","text":"<p>A clients represents an application that requests access to protected resources.</p> <p>This access can be on behalf of a user (in authorization code flow with PKCE), or for the client itself (in client credentials flow).</p>"},{"location":"how-it-works/#public-or-confidential-clients","title":"Public or confidential clients","text":"<p>Clients can be public or confidential.</p> <p>A public client is recommended for applications that cannot ensure the confidentiality of their client credentials. This is relevant for JavaScript-only web applications, where keeping a password confidential in JavaScript is not feasible due to its visibility. The same consideration applies to mobile apps, as an APK package can be downloaded and decompiled, exposing any secrets stored within.</p> <p>A confidential client is recommended for applications that can securely maintain the confidentiality of their client credentials. This applies to server-side applications, where the ability to protect and keep secrets confidential is feasible. In contrast to public clients, confidential clients, such as server-side web applications, can safely store sensitive information like passwords without exposing them to potential risks.</p>"},{"location":"how-it-works/#consent-required","title":"Consent required","text":"<p>In OAuth2, the consent process is vital to ensuring users explicitly authorize third-party applications to access their resources.</p> <p>Typically, when the client is affiliated with the same organization that owns the authorization server and a high level of trust exists, explicit consent may not be necessary.</p> <p>However, in the case of a client from a third-party organization, it's crucial to configure the client to request user consent. This ensures users are informed about who is utilizing their tokens, promoting transparency and user awareness.</p>"},{"location":"how-it-works/#default-acr-level","title":"Default ACR level","text":"<p>ACR stands for \"Authentication Context Class Reference.\" It's a way to specify the level of authentication assurance or the strength of the authentication method used to authenticate the end-user.</p> <p>Goiabada has 3 levels:</p> ACR level Description <code>urn:goiabada:pwd</code> Password only <code>urn:goiabada:pwd:otp_ifpossible</code> Password with 2fa OTP (if enabled) <code>urn:goiabada:pwd:otp_mandatory</code> Password with mandatory 2fa OTP <p>By default, a client comes configured with <code>urn:goiabada:pwd:otp_ifpossible</code>.</p> <p>You have the flexibility to override the client's default ACR level on a per-authorization basis. For instance, if you have a specific resource that requires users to authenticate using a two-factor authentication (2FA) one-time password (OTP), you can specify <code>urn:goiabada:pwd:otp_mandatory</code> in the <code>acr_values</code> parameter of the authorization request.</p>"},{"location":"how-it-works/#redirect-uris","title":"Redirect URIs","text":"<p>In the Authorization code flow with PKCE, the client application specifies a redirect URI in its authorization request.</p> <p>After the user grants or denies permission, the authorization server redirects the user back to this specified URI.</p> <p>It's necessary to pre-configure this URI in the client, and only exact matches are accepted (no wildcards are allowed). This helps ensure the security of the authorization process.</p>"},{"location":"how-it-works/#web-origins","title":"Web origins","text":"<p>If your client application plans to make calls to the <code>/token</code>, <code>/logout</code> or <code>/userinfo</code> endpoints from Javascript, you must register the URL (origin) of the web application here, to enable Cross-Origin Resource Sharing (CORS) access. Failure to do so will result in CORS blocking the HTTP requests.</p>"},{"location":"how-it-works/#client-permissions","title":"Client permissions","text":"<p>Client permissions are used in server-to-server exchanges, specifically within the client credentials flow. This is about the permissions granted to the client itself, allowing it to access other resources.</p>"},{"location":"how-it-works/#resources-and-permissions","title":"Resources and permissions","text":"<p>In Goiabada, you have the ability to define both resources and permissions. Each resource can have multiple permissions associated with it. Subsequently, you can assign these permissions to users, groups, or clients as needed.</p>"},{"location":"how-it-works/#scope","title":"Scope","text":"<p>When you pair a resource with a permission, it forms a scope, both in the authorization request and within the tokens. For example, if you have a resource identified as <code>product-api</code> and a permission identified as <code>delete-product</code> the corresponding scope will be represented as <code>product-api:delete-product</code>.</p>"},{"location":"how-it-works/#openid-connect-scopes","title":"OpenID Connect scopes","text":"<p>Besides the normal authorization scope explained earlier, Goiabada supports typical OpenID Connect scopes. They are:</p> OIDC scope Description openid Will include an <code>id_token</code> in the token response, with the subject identifier (<code>sub</code> claim) profile Access to claims: <code>name</code>, <code>family_name</code>, <code>given_name</code>, <code>middle_name</code>, <code>nickname</code>, <code>preferred_username</code>, <code>profile</code>, <code>website</code>, <code>gender</code>, <code>birthdate</code>, <code>zoneinfo</code>, <code>locale</code>, and <code>updated_at</code> email Access to claims: <code>email</code>, <code>email_verified</code> address Access to the <code>address</code> claim phone Access to claims: <code>phone_number</code> and <code>phone_number_verified</code> groups Access to the list of groups the user belongs to attributes Access to the attributes assigned to the user by an admin, stored as key-value pairs offline_access Access to a refresh token of the type <code>Offline</code>, allowing the client to obtain a new access token without requiring an immediate interaction"},{"location":"how-it-works/#user-sessions","title":"User sessions","text":"<p>User sessions facilitate the single sign-on (SSO) functionality of Goiabada. Once a user logs in, a new session starts. If they try to log in again and their session is still good, they don't need to go through the authentication process again.</p> <p>There are two configurations that are related to the user session:</p> Property Description User session idle timeout in seconds If there is no activity from the user within this timeframe, the session will be terminated. This will look into the <code>last_accessed</code> timestamp of the session. User session max lifetime in seconds The maximum duration a user session can last, irrespective of user activity. This will be checked against the <code>started</code> timestamp of the session. <p>A user session is bumped (which means, gets a new <code>last_accessed</code> timestamp) in two situations:</p> <ol> <li>When a new authorization request completes</li> <li>When a refresh token associated with the session is used to request a new access token</li> </ol> <p>In your authorization request, you have the option to include the <code>max_age</code> parameter. This parameter allows you to define the maximum acceptable time (in seconds) since the user's last authentication. For instance, if you add <code>max_age=120</code> to the authentication request, it implies that the user needs to re-authenticate if their last authentication was over 120 seconds (2 minutes) ago, regardless of having a valid session. This parameter is useful when the client needs to ensure that the user authenticated within a specific timeframe.</p>"},{"location":"how-it-works/#token-expiration","title":"Token expiration","text":"<p>You can customize the expiration durations (in seconds) for access tokens and id tokens on the Settings -&gt; Tokens page. These configurations apply globally to all clients. However, if needed, individual clients have the flexibility to override the global settings in their specific client configurations.</p> <p>The default token expiration is set to 5 minutes. Access tokens are intentionally kept short-lived, for security reasons.</p>"},{"location":"how-it-works/#refresh-tokens","title":"Refresh tokens","text":"<p>Refresh tokens are used in the authorization code flow with PKCE (in the client credentials flow we don't have refresh tokens). </p> <p>Goiabada supports two types of refresh tokens: normal and offline.</p> <p>Normal tokens are linked to the user session. They can be used to get a new access token, as long as there's an active user session. When a normal refresh token is used, the user session <code>last_accessed</code> timestamp is bumped. The expiration time of a normal refresh token is the same as the user session idle timeout (default is 2 hours). If the user session is terminated,  it will automatically invalidate the refresh tokens linked to that session.</p> <p>Offline refresh tokens are not linked to a user session. They can be used to obtain a new access token even when the user is not actively using the application. Their expiration time is long (defaults to 30 days).</p> <p>In your authorization request, when you ask for the <code>offline_access</code> scope, your refresh token will be classified as <code>offline</code>. Otherwise, if you don't include the <code>offline_access</code> scope, your refresh token will be considered normal.</p> <p>Upon each usage of a refresh token, the refresh token passed in to the <code>/auth/token</code> endpoint becomes inactive, and a new refresh token is provided in the token response. In other words, a refresh token is a one-time-use token; once used, it must be substituted with the new refresh token obtained from the response.</p>"},{"location":"how-it-works/#users-and-groups","title":"Users and groups","text":"<p>As an administrator of Goiabada you can create users and configure their properties (profile information, address, phone, email...). Also, you have the capability to modify their credentials, terminate active user sessions, and revoke consents.</p> <p>You can also assign permissions and attributes to individual users. Attributes are key-value pairs or arbitraty information, and can be included in the access token or id token.</p> <p>To facilitate user management, you can create groups of users. When you give a permission to a group, you give it to all group members. The same applies to attributes - group attributes will be included for all group members.</p>"},{"location":"how-it-works/#attributes","title":"Attributes","text":"<p>Attributes are arbitrary key-value pairs that you can associate with either a user or a group. When creating an attribute, you can choose to include it either in the access token or the id token.</p>"},{"location":"how-it-works/#self-registration","title":"Self registration","text":"<p>When the 'Self registration' setting is activated, users gain the ability to independently register their accounts using a link incorporated into the login form. Conversely, if this setting is disabled, only administrators have the privilege of creating new user accounts.</p> <p>Within the realm of self-registrations, there is an additional configuration option regarding the verification of the new user's email. Enabling this option ensures that the account becomes active only after the user clicks a link sent via email. To use this feature, it is imperative to configure your SMTP settings.</p>"},{"location":"how-it-works/#endpoints","title":"Endpoints","text":""},{"location":"how-it-works/#well-known-discovery-url","title":"Well-known discovery URL","text":"<p>You can find a link to the well-known discovery URL by going to the root of Goiabada (\"/\"). </p> <p><code>https://localhost:8100/.well-known/openid-configuration</code></p> <p>This endpoint will show the capabilities that are supported by Goiabada.</p>"},{"location":"how-it-works/#authauthorize-get","title":"/auth/authorize (GET)","text":"<p>The authorize endpoint is used to request authorization codes via the browser. This process normally involves authentication of the end-user and giving consent, when required.</p> <p>Parameters (* are mandatory):</p> Parameter Description client_id The client identifier. redirect_uri The redirect URI is the callback entry point of the app. In other words, it's the location where the authorization server sends the user once the <code>/auth/authorize</code> process completes. This must exactly match one of the allowed redirect URIs for the client. response_type <code>code</code> is the only value supported - for the authorization code flow with PKCE. code_challenge_method <code>S256</code> is the only value supported - for a SHA256 hash of the code verifier. code_challenge A random string between 43 and 128 characters long. response_mode Supported values: <code>query</code>, <code>fragment</code> or <code>form_post</code>. With <code>query</code> the authorization response parameters are encoded in the query string of the <code>redirect_uri</code>. With <code>fragment</code> they are encoded in the fragment (#). And <code>form_post</code> will make the parameters be encoded as HTML form values that are auto-submitted in the browser, via HTTP POST. max_age If the user's authentication timestamp exceeds the max age (in seconds), they will have to re-authenticate acr_values Supported values are: <code>urn:goiabada:pwd</code>, <code>urn:goiabada:pwd:otp_ifpossible</code> or <code>urn:goiabada:pwd:otp_mandatory</code>. This will override the default ACR level configured in the client for this authorization request. See Default ACR level. state Any string. Goiabada will echo back the state value on the token response, for CSRF/replay protection. nonce Any string. Goiabada will echo back the nonce value in the identity token, as a claim, for replay protection. scope One or more registered scopes, separated by a space character. A registered scope can be either a <code>resource:permission</code> or an OIDC scope. See Scope and OpenID Connect scopes."},{"location":"how-it-works/#authtoken-post","title":"/auth/token (POST)","text":"<p>The token endpoint serves the purpose of requesting tokens. This can happen either through the authorization code flow, involving the exchange of an authorization code for tokens, or through the client credentials flow, where a client directly requests tokens.</p> <p>Parameters:</p> Parameter Description grant_type Supported grant types are <code>authorization_code</code> (to exchange an authorization code for tokens), <code>client_credentials</code> (for the client credentials flow) or <code>refresh_token</code> (to use a refresh token). client_id The client identifier. client_secret The client secret, if it's a confidential client. redirect_uri Required for the <code>authorization_code</code> grant type. code The authorization code. Required for the <code>authorization_code</code> grant type. code_verifier This is the code verifier associated with the PKCE request, initially generated by the app before the authorization request. It represents the original string from which the <code>code_challenge</code> was derived. scope This parameter is used in the <code>client_credentials</code> and <code>refresh_token</code> grant types. In <code>client_credentials</code> grant type, it's a mandatory parameter, and it should encompass one or more registered scopes, separated by a space character. These scopes represent the requested permissions in the format of <code>resource:permission</code>. For the <code>refresh_token</code> grant type, the scope parameter is optional and serves to restrict the original scope to a more specific and narrower subset. refresh_token The refresh token, required for the <code>refresh_token</code> grant type."},{"location":"how-it-works/#authlogout-get-or-post","title":"/auth/logout (GET or POST)","text":"<p>This endpoint enables the client application to initiate a logout. The client application calls this logout endpoint on the auth server. Upon successful logout from the auth server, the user agent is then redirected to a logout link within the client application. This implementation aligns with the OpenID Connect RP-Initiated Logout 1.0 protocol.</p> <p>If the <code>/auth/logout</code> endpoint is invoked without parameters, it will display a logout consent screen, prompting the user to confirm their intention to log out. Moreover, there will be no redirection to the client application in this scenario.</p> <p>The recommended way of calling <code>/auth/logout</code> involves including additional parameters:</p> Parameter Description id_token_hint The previously issued id token. post_logout_redirect_uri A post-logout URI, which must be pre-registered with the client as a redirect URI. Once the logout is finalized on the authentication server, the user agent will be redirected to this post-logout URI. This allows for the termination of the session on the client application as well. client_id The client identifier. Mandatory if the <code>id_token_hint</code> parameter is encrypted with the client secret. state Any arbitraty string that will be echoed back in the <code>post_logout_redirect_uri</code>. <p>The two possible routes are:</p> <ol> <li><code>id_token_hint</code> (unencrypted) + <code>post_logout_redirect_uri</code> + <code>state</code> (optional).  </li> <li><code>id_token_hint</code> (encrypted with AES GCM) + <code>post_logout_redirect_uri</code> + <code>client_id</code> + <code>state</code> (optional).  </li> </ol> <p>Encrypting the <code>id_token_hint</code> (option 2) enhances security by preventing the exposure of the ID token on the client side. Without encryption, calling this endpoint with an unencrypted <code>id_token_hint</code> could potentially expose personally identifiable information (PII) and other claims that are inside of the id token, such as the client identifier.</p> <p>Below are some examples on how to encrypt the id token for the <code>id_token_hint</code> parameter. You must URL-encode the resulting base64 string, when sending it as querystring parameter to <code>/auth/logout</code>.</p>"},{"location":"how-it-works/#net-c","title":".NET C#","text":"<pre><code>private static string AesGcmEncryption(string idTokenUnencrypted, \n    string clientSecret)\n{\n    var key = new byte[32];\n\n    // use the first 32 bytes of the client secret as key\n    var keyBytes = Encoding.UTF8.GetBytes(clientSecret);\n    Array.Copy(keyBytes, key, Math.Min(keyBytes.Length, key.Length));\n\n    // random nonce\n    var nonce = new byte[AesGcm.NonceByteSizes.MaxSize]; // MaxSize = 12\n    RandomNumberGenerator.Fill(nonce);\n\n    using var aes = new AesGcm(key);\n    var cipherText = new byte[idTokenUnencrypted.Length];\n    var tag = new byte[AesGcm.TagByteSizes.MaxSize]; // MaxSize = 16\n    aes.Encrypt(nonce, Encoding.UTF8.GetBytes(idTokenUnencrypted), \n        cipherText, tag);\n\n    // concatenate nonce (12 bytes) + ciphertext (? bytes) + tag (16 bytes)\n    var encrypted = new byte[nonce.Length + cipherText.Length + tag.Length];\n    Array.Copy(nonce, encrypted, nonce.Length);\n    Array.Copy(cipherText, 0, encrypted, nonce.Length, cipherText.Length);\n    Array.Copy(tag, 0, encrypted, nonce.Length + cipherText.Length, tag.Length);\n\n    return Convert.ToBase64String(encrypted);\n}\n</code></pre>"},{"location":"how-it-works/#go","title":"Go","text":"<pre><code>import (\n    \"crypto/aes\"\n    \"crypto/cipher\"\n    \"crypto/rand\"\n    \"encoding/base64\"\n    \"io\"\n    \"math\"\n)\n\nfunc AesGcmEncryption(idTokenUnencrypted string, clientSecret string) (string, error) {\n    key := make([]byte, 32)\n\n    // Use the first 32 bytes of the client secret as key\n    keyBytes := []byte(clientSecret)\n    copy(key, keyBytes[:int(math.Min(float64(len(keyBytes)), float64(len(key))))])\n\n    // Random nonce\n    nonce := make([]byte, 12)\n    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {\n        return \"\", err\n    }\n\n    block, err := aes.NewCipher(key)\n    if err != nil {\n        return \"\", err\n    }\n\n    aesGcm, err := cipher.NewGCM(block)\n    if err != nil {\n        return \"\", err\n    }\n\n    cipherText := aesGcm.Seal(nil, nonce, []byte(idTokenUnencrypted), nil)\n\n    // Concatenate nonce (12 bytes) + ciphertext (? bytes) + tag (16 bytes)\n    encrypted := make([]byte, len(nonce)+len(cipherText))\n    copy(encrypted, nonce)\n    copy(encrypted[len(nonce):], cipherText)\n\n    return base64.StdEncoding.EncodeToString(encrypted), nil\n}\n</code></pre>"},{"location":"how-it-works/#nodejs","title":"NodeJS","text":"<pre><code>const crypto = require('crypto');\n\nfunction aesGcmEncryption(idTokenUnencrypted, clientSecret) {\n    const key = Buffer.alloc(32);\n\n    // Use the first 32 bytes of the client secret as the key\n    const keyBytes = Buffer.from(clientSecret, 'utf-8');\n    keyBytes.copy(key, 0, 0, Math.min(keyBytes.length, key.length));\n\n    // Random nonce\n    const nonce = crypto.randomBytes(12);\n\n    const cipher = crypto.createCipheriv('aes-256-gcm', key, nonce);\n    let cipherText = cipher.update(idTokenUnencrypted, 'utf-8', 'base64');\n    cipherText += cipher.final('base64');\n\n    const tag = cipher.getAuthTag();\n\n    // Concatenate nonce (12 bytes) + ciphertext (? bytes) + tag (16 bytes)\n    const encrypted = Buffer.concat([nonce, Buffer.from(cipherText, 'base64'), tag]);\n\n    return encrypted.toString('base64');\n}\n</code></pre> <p>You can explore the libraries available on your platform and adopt the same approach.</p>"},{"location":"how-it-works/#userinfo-get-or-post","title":"/userinfo (GET or POST)","text":"<p>The UserInfo endpoint, a component of OpenID Connect, serves the purpose of retrieving identity information about a user.</p> <p>The caller needs to send a valid access token to be able to access this endpoint. This is done by adding the <code>Authorization: Bearer token-value</code> header to the HTTP request.</p> <p>The endpoint validates the presence of the <code>authserver:userinfo</code> scope within the access token. If this scope is present, the endpoint responds by providing claims about the user. </p> <p>Please note that you don't need to manually request the <code>authserver:userinfo</code> scope in the authorization request. Instead, it will be automatically included in the access token whenever any OpenID Connect scope is included in the request.</p> <p>The specific claims returned by the UserInfo endpoint depend on the OpenID Connect scopes included in the access token. For instance, if the <code>openid</code> and <code>email</code> scopes are present, the endpoint will return the <code>sub</code> (subject) claim from the <code>openid</code> scope, as well as the <code>email</code> and <code>email_verified</code> claims from the email scope.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#docker-compose","title":"Docker compose","text":"<p>The recommended and most convenient way to use Goiabada is via a container. Container images are available in docker hub.</p> <p>To get started, feel free to use and customize the following docker compose file. You can read more about the environment variables here.</p> docker-compose.yml<pre><code>version: '3.8'\nservices:\n\n  mysql-server:\n    image: mysql:latest\n    restart: unless-stopped\n    ports:\n      # host_port:container_port\n      - 3100:3306  \n    volumes:\n      - mysql-data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: mySqlPass123\n    healthcheck:\n      # important: keep user (-u) and password (-p) below in sync \n      # with environment variables GOIABADA_DB_USERNAME, GOIABADA_DB_PASSWORD \n      # and MYSQL_ROOT_PASSWORD      \n      test: [\"CMD\", \"mysqladmin\", \"ping\", \"-uroot\", \"-pmySqlPass123\",  \"--protocol\", \"tcp\"]\n      interval: 1s\n      timeout: 2s\n      retries: 20\n    networks: \n      - goiabada-network  \n\n  goiabada:\n    image: leodip/goiabada:latest\n    restart: unless-stopped\n    depends_on: \n      mysql-server:\n        condition: service_healthy    \n    ports:\n      # host_port:container_port\n      - 8100:80 # http\n      #- 8100:443 # https    \n    command: sleep infinity\n    networks: \n      - goiabada-network\n    environment:\n      # See all timezones:\n      # https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n      - TZ=Europe/Lisbon \n\n      # The email address of the admin user (the first user created)\n      - GOIABADA_ADMIN_EMAIL=admin@example.com\n\n      # The password of the admin user (the first user created)\n      - GOIABADA_ADMIN_PASSWORD=changeme\n\n      # The name of the application\n      - GOIABADA_APPNAME=Goiabada\n\n      # Without TLS (http) - do not use in production!\n      - GOIABADA_ISSUER=http://localhost:8100\n      - GOIABADA_BASEURL=http://localhost:8100\n      - GOIABADA_CERTFILE= #leave this empty to use http\n      - GOIABADA_KEYFILE= #leave this empty to use http\n      - GOIABADA_HOST= # leave this empty to listen on all available interfaces\n      - GOIABADA_PORT=80\n      - GOIABADA_RATELIMITER_ENABLED=true # built-in HTTP rate limiter\n      - GOIABADA_RATELIMITER_MAXREQUESTS=50 # max requests per time window\n      - GOIABADA_RATELIMITER_WINDOWSIZEINSECONDS=10 # time window in seconds\n\n      # # With TLS (https)\n      # - GOIABADA_ISSUER=http://localhost:8100\n      # - GOIABADA_BASEURL=http://localhost:8100\n      # - GOIABADA_CERTFILE=./cert/self_signed_cert.pem #certificate file (for https)\n      # - GOIABADA_KEYFILE=./cert/self_signed_key.pem # private key file (for https)\n      # - GOIABADA_HOST= # leave this empty to listen on all available interfaces\n      # - GOIABADA_PORT=443\n\n      # The directory where the templates and static files are located\n      - GOIABADA_TEMPLATEDIR=./web/template #leave this empty to use embedded templates\n      - GOIABADA_STATICDIR=./web/static #leave this empty to use embedded static files\n\n      # If you want to use a reverse proxy in front of Goiabada, set this to true\n      - GOIABADA_ISBEHINDAREVERSEPROXY=false\n\n      # Database (mysql) details\n      - GOIABADA_DB_HOST=mysql-server\n      - GOIABADA_DB_PORT=3306\n      - GOIABADA_DB_DBNAME=goiabada\n      - GOIABADA_DB_USERNAME=root\n      - GOIABADA_DB_PASSWORD=mySqlPass123\n\n      # GORM (sql ORM) - trace all SQL: true, false\n      - GOIABADA_LOGGER_GORM_TRACEALL=false\n\n      # Http requests logging: true, false\n      - GOIABADA_LOGGER_ROUTER_HTTPREQUESTS_ENABLED=true\n\n      # Audit messages in console log: true, false\n      - GOIABADA_AUDITING_CONSOLELOG_ENABLED=true\n\nvolumes:\n  mysql-data:\n\nnetworks:\n  goiabada-network:\n</code></pre> <p>If you have Docker working in your environment, save the above file and execute the following command:</p> <p><code>docker compose up -d</code></p> <p>Once the container is ready, you can access the application using the URL:</p> <p>http://localhost:8100</p> <p>The default admin credentials are:</p> <pre><code>Email: admin@example.com\nPassword: changeme\n</code></pre> <p>Important: the docker compose file given above is set up with HTTP (non-TLS), making it insecure. HTTP should only be used for testing or development purposes.</p>"},{"location":"installation/#ssl-certs","title":"SSL certs","text":"<p>HTTPS/TLS is essential for Goiabada to function securely. When you have the SSL cert for your domain, remember to make it available to the container, using a volume. Then, amend the environment variables <code>GOIABADA_CERTFILE</code> and <code>GOIABADA_KEYFILE</code> to point to your certification and key files, accordingly. Don't forget to use the correct port in your docker compose file.</p> <p>You can have a look at the documentation of Docker https://docs.docker.com/compose/compose-file/07-volumes/ for details on how to map a volume.</p>"},{"location":"integration/","title":"Integration","text":"<p>To integrate Goiabada with your app, you'll need to explore your platform for an OAuth2/OpenID Connect client library. Many platforms provide such libraries for integration.</p>"},{"location":"integration/#javascript-only","title":"Javascript-only","text":"<p>The github repository of Goiabada has a browser-based javascript test client that you can use to test Goiabada. It uses the oauth4webapi library.</p>"},{"location":"integration/#dotnet-c-example","title":"dotnet C# example","text":"<p>We also have a sample integration using dotnet C#.</p> <p></p> <p>The components of the solution are:</p> <ul> <li>A frontend web app application (ASP.NET razor pages) that requires the users to be authenticated in order to access an area of the site.</li> <li>A backend web api application (ASP.NET web api) responsible for serving weather forecasts. This API requires the permission <code>weather-forecast:read</code>.</li> </ul> <p>The example uses OpenID Connect (authorization code flow with PKCE) to authenticate users on the frontend. Additionally, the client credentials flow is employed for the frontend server to obtain an access token for accessing the backend server.</p> <p>Additionally, it implements secure logout (with encryption of the id token), and automatic refresh of the access tokens.</p> <p>Please clone the repo to have access to the code. It is located here - https://github.com/leodip/goiabada/tree/main/test-integrations/dotnet6.</p> <p>To run the example locally you need:</p> <ol> <li>An instance of Goiabada running. The example is configured to use <code>https://localhost:8080</code> as Goiabada's base URL, but you can change this in <code>appsettings.json</code> if you want.</li> <li>A client created in Goiabada called <code>dotnet6-integration-frontend</code>, with both Authorization code with PKCE and Client credentials flows enabled. </li> <li>You must also register these two redirect URIs within the <code>dotnet6-integration-frontend</code> client: <code>https://localhost:7096/signin-oidc</code> and <code>https://localhost:7096/LogoutFrontend</code>.</li> <li>In Goiabada, you need a resource with identifier <code>weather-forecast</code>. In this resource, you need a permission with identifier <code>read</code>.</li> <li>You must assign the permission <code>weather-forecast:read</code> to client <code>dotnet6-integration-frontend</code>.</li> <li>You must copy the client secret of <code>dotnet6-integration-frontend</code> to the configuration file <code>Goiabada.TestIntegration.Frontend/appsettings.json</code> (<code>OpenIDConnect:ClientSecret</code> and <code>WeatherForecastService:ClientSecret</code>)</li> </ol> <p>Finally, please make sure Goiabada is running, start up <code>Goiabada.TestIntegration.Backend</code> application (web api) and start up <code>Goiabada.TestIntegration.Frontend</code> application (razor pages). Then visit <code>https://localhost:7096</code> in your browser.</p>"},{"location":"license/","title":"License","text":""},{"location":"license/#intro","title":"Intro","text":"<p>Goiabada is open source and 100% free of charge. You can do whatever you want with the software, as long as you include the original copyright and license notice in any copy of the software/source.</p>"},{"location":"license/#full-license-text","title":"Full license text","text":"<pre><code>MIT License\n\nCopyright (c) 2023 Leonardo D'Ippolito (contact@leodip.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"}]}