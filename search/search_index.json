{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Goiabada","text":"<p>Goiabada is an open-source authentication and authorization server. </p> <p>Goiabada makes user management easy for app developers. You can set up users, groups, resources, and permissions to integrate with your software. Plus, it handles authentication and authorization for server-to-server connections too.</p> <ul> <li>Built with Go for speed and low resource usage</li> <li>Easy-to-use interface</li> <li>Supports Single Sign-On (SSO)</li> <li>Two-factor authentication (2FA) with one-time passwords (OTP)</li> <li>Fine-tuned control over resources and permissions</li> <li>Self-service account page for users to update their details</li> <li>OAuth2 support, including authorization code flow and client credentials flow</li> <li>OpenID Connect support</li> <li>Databases supported: MySQL, PostgreSQL, Microsoft SQL Server, SQLite</li> </ul>"},{"location":"#screenshots","title":"Screenshots","text":""},{"location":"about/","title":"About","text":"<p>Goiabada was developed to be an easy-to-use container for user management. Plenty of alternatives exist, but this is my personal take on the concept.</p> <p>I'm committed to make Goiabada forever free and open source. I want you to self host it and have total control over the code and data.</p> <p>The name is inspired by a Brazilian sweet made with guava. I was keen on choosing a word that started with Go \ud83d\ude09</p> <p></p> <p>Don't hesitate to contact me at contact@leodip.com, or consider visiting my blog or LinkedIn profile.</p> <p>Leonardo D'Ippolito</p>"},{"location":"config/","title":"Config","text":"<p>Goiabada uses environment variables and/or executable flags to configure its behavior. </p> <p>If both an environment variable and a flag are set, the flag takes precedence.</p> <p><code>GOIABADA_AUTHSERVER_BASEURL</code> and <code>GOIABADA_ADMINCONSOLE_BASEURL</code></p> <p>Flag: <code>--authserver-baseurl</code> and <code>--adminconsole-baseurl</code></p> <p>Default: http://localhost:9090 (auth server) and http://localhost:9091 (admin console)</p> <p>Description: The base URL of the application. This is used for external access into the application.</p> <p><code>GOIABADA_AUTHSERVER_INTERNALBASEURL</code> and <code>GOIABADA_ADMINCONSOLE_INTERNALBASEURL</code></p> <p>Flag: <code>--authserver-internalbaseurl</code> and <code>--adminconsole-internalbaseurl</code></p> <p>Default: (empty string)</p> <p>Description: The internal base URL of the application. This is used for internal communication (for instance, when the <code>adminconsole</code> needs to call the <code>token</code> endpoint on the <code>authserver</code>)</p> <p><code>GOIABADA_AUTHSERVER_LISTEN_HOST_HTTPS</code> and <code>GOIABADA_ADMINCONSOLE_LISTEN_HOST_HTTPS</code></p> <p>Flag: <code>--authserver-listen-host-https</code> and <code>--adminconsole-listen-host-https</code></p> <p>Default: 0.0.0.0 (all network interfaces)</p> <p>Description: The host to listen on for HTTPS access.</p> <p><code>GOIABADA_AUTHSERVER_LISTEN_PORT_HTTPS</code> and <code>GOIABADA_ADMINCONSOLE_LISTEN_PORT_HTTPS</code></p> <p>Flag: <code>--authserver-listen-port-https</code> and <code>--adminconsole-listen-port-https</code></p> <p>Default: 9443 (auth server) and 9444 (admin console)</p> <p>Description: The port to listen on for HTTPS access.</p> <p><code>GOIABADA_AUTHSERVER_LISTEN_HOST_HTTP</code> and <code>GOIABADA_ADMINCONSOLE_LISTEN_HOST_HTTP</code></p> <p>Flag: <code>--authserver-listen-host-http</code> and <code>--adminconsole-listen-host-http</code></p> <p>Default: 0.0.0.0 (all network interfaces)</p> <p>Description: The host to listen on for HTTP access.</p> <p><code>GOIABADA_AUTHSERVER_LISTEN_PORT_HTTP</code> and <code>GOIABADA_ADMINCONSOLE_LISTEN_PORT_HTTP</code></p> <p>Flag: <code>--authserver-listen-port-http</code> and <code>--adminconsole-listen-port-http</code></p> <p>Default: 9090 (auth server) and 9091 (admin console)</p> <p>Description: The port to listen on for HTTP access.</p> <p><code>GOIABADA_AUTHSERVER_TRUST_PROXY_HEADERS</code> and <code>GOIABADA_ADMINCONSOLE_TRUST_PROXY_HEADERS</code></p> <p>Flag: <code>--authserver-trust-proxy-headers</code> and <code>--adminconsole-trust-proxy-headers</code></p> <p>Default: false</p> <p>Description: If you're using a reverse proxy, you should trust the headers sent by it. The <code>True-Client-IP</code>, <code>X-Real-IP</code> or the <code>X-Forwarded-For</code> header will be used to get the client's IP address. If you're not using a reverse proxy, you should set those variables to <code>false</code>.</p> <p><code>GOIABADA_AUTHSERVER_SET_COOKIE_SECURE</code> and <code>GOIABADA_ADMINCONSOLE_SET_COOKIE_SECURE</code></p> <p>Flag: <code>--authserver-set-cookie-secure</code> and <code>--adminconsole-set-cookie-secure</code></p> <p>Default: false</p> <p>Description: This should always be set to <code>true</code> in production, when using HTTPS. The only scenario where they should be <code>false</code> is when testing locally with HTTP only.</p> <p><code>GOIABADA_AUTHSERVER_LOG_HTTP_REQUESTS</code> and <code>GOIABADA_ADMINCONSOLE_LOG_HTTP_REQUESTS</code></p> <p>Flag: <code>--authserver-log-http-requests</code> and <code>--adminconsole-log-http-requests</code></p> <p>Default: false</p> <p>Description: If <code>true</code>, log the HTTP requests to console.</p> <p><code>GOIABADA_AUTHSERVER_CERTFILE</code> and <code>GOIABADA_ADMINCONSOLE_CERTFILE</code></p> <p>Flag: <code>--authserver-certfile</code> and <code>--adminconsole-certfile</code></p> <p>Default: (empty string)</p> <p>Description: Certificate file for HTTPS. If empty, TLS will not be enabled.</p> <p><code>GOIABADA_AUTHSERVER_KEYFILE</code> and <code>GOIABADA_ADMINCONSOLE_KEYFILE</code></p> <p>Flag: <code>--authserver-keyfile</code> and <code>--adminconsole-keyfile</code></p> <p>Default: (empty string)</p> <p>Description: key file for HTTPS. If empty, TLS will not be enabled.</p> <p><code>GOIABADA_AUTHSERVER_LOG_SQL</code> and <code>GOIABADA_ADMINCONSOLE_LOG_SQL</code></p> <p>Flag: <code>--authserver-log-sql</code> and <code>--adminconsole-log-sql</code></p> <p>Default: false</p> <p>Description: If <code>true</code>, log all SQL statements to console.</p> <p><code>GOIABADA_AUTHSERVER_AUDIT_LOGS_IN_CONSOLE</code> and <code>GOIABADA_ADMINCONSOLE_AUDIT_LOGS_IN_CONSOLE</code></p> <p>Flag: <code>--authserver-audit-logs-in-console</code> and <code>--adminconsole-audit-logs-in-console</code></p> <p>Default: false</p> <p>Description: If <code>true</code>, log audit messages to console.</p> <p><code>GOIABADA_AUTHSERVER_STATICDIR</code> and <code>GOIABADA_ADMINCONSOLE_STATICDIR</code></p> <p>Flag: <code>--authserver-staticdir</code> and <code>--adminconsole-staticdir</code></p> <p>Default: (empty string)</p> <p>Description: The directory where the static files are located. If empty, it uses the static files embedded into the binary. This config is useful when you want to make modifications to the static files and serve them from the filesystem (perhaps via a docker volume, when running in a container).</p> <p><code>GOIABADA_AUTHSERVER_TEMPLATEDIR</code> and <code>GOIABADA_ADMINCONSOLE_TEMPLATEDIR</code></p> <p>Flag: <code>--authserver-templatedir</code> and <code>--adminconsole-templatedir</code></p> <p>Default: (empty string)</p> <p>Description: The directory where the HTML templates are located. If empty, it uses the HTML templates embedded into the binary. This config is useful when you want to make modifications to the templates and serve them from the filesystem (perhaps via a docker volume, when running in a container).</p> <p><code>GOIABADA_DB_TYPE</code></p> <p>Flag: <code>--db-type</code></p> <p>Default: sqlite</p> <p>Description: Currently <code>mysql</code>, <code>postgres</code>, <code>mssql</code>, <code>sqlite</code> are supported.</p> <p><code>GOIABADA_DB_USERNAME</code></p> <p>Flag: <code>--db-username</code></p> <p>Default: root</p> <p>Description: DB user's name.</p> <p><code>GOIABADA_DB_PASSWORD</code></p> <p>Flag: <code>--db-password</code></p> <p>Default: (empty string)</p> <p>Description: DB user's password.</p> <p><code>GOIABADA_DB_HOST</code></p> <p>Flag: <code>--db-host</code></p> <p>Default: localhost</p> <p>Description: DB server hostname.</p> <p><code>GOIABADA_DB_PORT</code></p> <p>Flag: <code>--db-port</code></p> <p>Default: 3306</p> <p>Description: DB server TCP port.</p> <p><code>GOIABADA_DB_NAME</code></p> <p>Flag: <code>--db-name</code></p> <p>Default: goiabada</p> <p>Description: Database (schema) name.</p> <p><code>GOIABADA_DB_DSN</code></p> <p>Flag: <code>--db-dsn</code></p> <p>Default: file::memory:?cache=shared</p> <p>Description: DSN of the database. Only applicable when db type is <code>sqlite</code>. When using a file, don't forget to add <code>?_pragma=busy_timeout=5000&amp;_pragma=journal_mode=WAL</code>. </p> <p>Example: <code>file:/home/john/goiabada.db?_pragma=busy_timeout=5000&amp;_pragma=journal_mode=WAL</code></p> <p><code>GOIABADA_ADMIN_EMAIL</code></p> <p>Flag: <code>--admin-email</code></p> <p>Default: admin</p> <p>Description: The email address of the admin user (the first user created). This is only relevant when the application is started for the first time.</p> <p><code>GOIABADA_ADMIN_PASSWORD</code></p> <p>Flag: <code>--admin-password</code></p> <p>Default: changeme</p> <p>Description: The password of the admin user (the first user created). This is only relevant when the application is started for the first time.</p> <p><code>GOIABADA_APPNAME</code></p> <p>Flag: <code>--appname</code></p> <p>Default: Goiabada</p> <p>Description: The name of the application. This is used in the UI and is only relevant when the application is started for the first time (it can be changed in the <code>adminconsole</code> later).</p>"},{"location":"customizations/","title":"Customize","text":""},{"location":"customizations/#app-name-issuer-and-ui-theme","title":"App name, issuer and UI theme","text":"<p>The most basic level of customization is to set the app name, issuer (the same as the public deployment URL) and also choosing a UI theme. Those things should be customized in the admin area, using the web interface.</p>"},{"location":"customizations/#html-templates","title":"HTML templates","text":"<p>You can also modify any HTML template of Goiabada, if you wish, provided you don't break the existing UI code (the javascript sections, element ids, etc.). You need to be careful and know what you're doing.</p> <p>The overall strategy is:</p> <ol> <li>copy the <code>web</code> folder from container to host</li> <li>make your modifications in the HTML/CSS files</li> <li>relaunch the Goiabada container with a volume, mapping from host folder to container folder.</li> <li>set <code>GOIABADA_AUTHSERVER_TEMPLATEDIR</code> and/or <code>GOIABADA_ADMINCONSOLE_TEMPLATEDIR</code> to mapped folder. You can also set <code>GOIABADA_AUTHSERVER_STATICDIR</code> and/or <code>GOIABADA_ADMINCONSOLE_STATICDIR</code> to a mapped folder, if you want to serve static files from the filesystem.</li> </ol>"},{"location":"customizations/#tailwind-css","title":"Tailwind CSS","text":"<p>Goiabada uses Tailwind CSS. When customizing the templates you can add/change Tailwind CSS classes if you wish. If you do that, it's necessary that you run the Tailwind CLI tool, after you finish editing the files. The Tailwind CLI tool will regenerate the file <code>main.css</code> that is used by the application.</p> <p>You can download the Tailwind CLI tool here: https://tailwindcss.com/blog/standalone-cli.</p> <p>Here's how you can regenerate the <code>main.css</code> file:</p> <pre><code>(the current folder here is one level up the web folder)\n\ntailwindcss -c ./web/tailwindcss/tailwind.config.js -i ./web/tailwindcss/input.css -o ./web/static/main.css\n</code></pre>"},{"location":"development/","title":"Development","text":"<p>Goibada was developed in Go using Linux (\u2764\ufe0f). The github repository has a vscode dev container with all the dependencies pre-configured to run Goiabada locally. </p> <p>To get started, simply clone the repository, install Microsoft's Dev Containers extension and open it in the dev container. You can <code>make serve</code> the authserver and <code>make serve</code> the adminconsole, from their respective folders. That will give you a running Goiabada.</p> <p>For integration tests, first <code>make serve</code> the authserver to start it, then in another terminal use the <code>make test-local</code> script from the authserver folder, to run the tests.</p> <p>Goiabada uses go-sqlbuilder for SQL generation, Tailwind CSS with DaisyUI for UI &amp; styling, and the chi router to manage the incoming HTTP requests.</p> <p>Bug reports and pull requests are encouraged. You can reach out to me at contact@leodip.com. Your involvement is welcome and appreciated.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#overview-of-goiabada-architecture","title":"Overview of Goiabada architecture","text":"<p>Goiabada is made up of three main parts:</p> <ul> <li>the auth server, which manages key endpoints for authorization, token exchange, and authentication forms; </li> <li>the admin console, where you can change settings and manage user accounts and profiles;</li> <li>and lastly, a database that's used by both.</li> </ul> <p></p>"},{"location":"getting-started/#how-to-run-it","title":"How to run it?","text":"<p>The easiest and recommended way to use Goiabada is through containers, with images available on docker hub.</p> <p>You can also find pre-built binaries on the releases page of github if you prefer to work without containers.</p>"},{"location":"getting-started/#i-just-want-to-test-it-locally","title":"I just want to test it locally","text":"<p>Ok, let's use HTTP only. (never do this in production!)</p> <p>Save this docker compose file and do:</p> <pre><code>docker compose -f docker-compose-mysql.yml up -d\n</code></pre> <p>We also support postgres, mssql and sqlite.</p> <p>If you want to test it with sqlite you can use this docker compose file instead. </p> <pre><code>docker compose -f docker-compose-sqlite.yml up -d\n</code></pre> <p>For more details on environment variables, check here.</p>"},{"location":"getting-started/#i-want-to-deploy-and-expose-it-directly-to-the-internet-without-a-reverse-proxy","title":"I want to deploy and expose it directly to the internet without a reverse proxy","text":"<p>To deploy and expose Goiabada directly to the internet, you'll need to configure both HTTPS (for external access) and HTTP (for internal communication).</p> <p>Do not expose the HTTP port to the internet, only the HTTPS. Keep the HTTP port restricted to internal use.</p> <p>When starting two web applications (<code>authserver</code> and <code>adminconsole</code>) on the same server, it's not possible for both apps to listen on port 443 simultaneously. You can set one application to listen on port 443 and assign a different port to the other.</p> <p>To make this work you'll also need SSL certificates. If you don't have them, you can generate free SSL certificates using Let's Encrypt (see example).</p> <p>Use this docker compose file as a starting point.</p>"},{"location":"getting-started/#i-want-to-deploy-and-have-goiabada-behind-a-reverse-proxy","title":"I want to deploy and have Goiabada behind a reverse proxy","text":"<p>Using a reverse proxy (like Nginx) offers some advantages when deploying Goiabada. It allows both the <code>authserver</code> and <code>adminconsole</code> applications to share port 443.</p> <p>In this setup you should make Goiabada use HTTP only, and let the reverse proxy handle the HTTPS.</p> <p>Use this docker compose file as a starting point.</p> <p>Here's an example of Nginx configuration:</p> <pre><code># /etc/nginx/conf.d/demo-goiabada.conf\n\n# Auth Server\nserver {\n    listen 443 ssl http2;\n    listen [::]:443 ssl http2;\n    server_name demo-authserver.goiabada.dev;\n\n    # SSL configuration\n    ssl_certificate /etc/letsencrypt/live/demo-authserver.goiabada.dev/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/demo-authserver.goiabada.dev/privkey.pem;\n\n    # SSL parameters\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers HIGH:!aNULL:!MD5;\n    ssl_prefer_server_ciphers on;\n\n    # Security headers\n    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\n    add_header X-Frame-Options \"SAMEORIGIN\" always;\n    add_header X-Content-Type-Options \"nosniff\" always;\n\n    location / {\n        proxy_pass http://127.0.0.1:9090;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n\n# Admin Console\nserver {\n    listen 443 ssl http2;\n    listen [::]:443 ssl http2;\n    server_name demo-adminconsole.goiabada.dev;\n\n    # SSL configuration\n    ssl_certificate /etc/letsencrypt/live/demo-adminconsole.goiabada.dev/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/demo-adminconsole.goiabada.dev/privkey.pem;\n\n    # SSL parameters\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers HIGH:!aNULL:!MD5;\n    ssl_prefer_server_ciphers on;\n\n    # Security headers\n    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\n    add_header X-Frame-Options \"SAMEORIGIN\" always;\n    add_header X-Content-Type-Options \"nosniff\" always;\n\n    location / {\n        proxy_pass http://127.0.0.1:9091;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n\n# HTTP redirect to HTTPS\nserver {\n    listen 80;\n    listen [::]:80;\n    server_name demo-authserver.goiabada.dev demo-adminconsole.goiabada.dev;\n\n    location / {\n        return 301 https://$host$request_uri;\n    }\n}\n</code></pre>"},{"location":"getting-started/#first-login","title":"First login","text":"<p>Once the containers are up and running, you can access the admin console at the URL configured. </p> <p>The admin credentials are either what you've set in the environment variables, or by default:</p> <pre><code>Email: admin@example.com\nPassword: changeme\n</code></pre>"},{"location":"getting-started/#trust-reverse-proxy-headers-and-secure-cookie","title":"Trust reverse proxy headers and secure cookie","text":"<p>If you're using a reverse proxy, you should trust the headers sent by it. Make sure these are <code>true</code>:</p> <pre><code>GOIABADA_AUTHSERVER_TRUST_PROXY_HEADERS=true\nGOIABADA_ADMINCONSOLE_TRUST_PROXY_HEADERS=true\n</code></pre> <p>The <code>True-Client-IP</code>, <code>X-Real-IP</code> or the <code>X-Forwarded-For</code> header will be used to get the client's IP address.</p> <p>If you're not using a reverse proxy, you should set those variables to <code>false</code>.</p> <p>Also, this should always be set to <code>true</code> in production, when using HTTPS:</p> <pre><code>GOIABADA_AUTHSERVER_SET_COOKIE_SECURE=true\nGOIABADA_ADMINCONSOLE_SET_COOKIE_SECURE=true\n</code></pre> <p>The only scenario where they should be <code>false</code> is when testing locally with HTTP only.</p>"},{"location":"how-it-works/","title":"How it works","text":""},{"location":"how-it-works/#use-cases","title":"Use cases","text":"<p>Goiabada is useful in two main scenarios:</p> <ol> <li>When users need access to specific resources (such as a section of your application or an API) and you want to manage that access.</li> <li>When servers need to access other servers, and you want to set defined permission levels for them.</li> </ol> <p>Let's view those in more details.</p>"},{"location":"how-it-works/#users-accessing-resources","title":"Users accessing resources","text":"<p>When you have users accessing resources, you basically need to know: who the user is (authentication), and whether they're authorized to access that resource (authorization).</p> <p>Goiabada works with two familiar web protocols to fulfil that: OpenID Connect handles the who's who (authentication), and OAuth2 takes care of who can do what (authorization).</p> <p>Regardless of your app type (a web app on the server side, a web app using JavaScript, or a mobile native app), the recommended approach is the Authorization code flow with PKCE.</p> <p>The Authorization code flow with PKCE is a secure method for handling user authentication in web applications. It works in two steps: first, the application requests an authorization code from the <code>/authorize</code> endpoint. Then, it exchanges this code for an access token, a refresh token, and optionally an ID token at the <code>/token</code> endpoint.</p> <p>PKCE adds an extra layer of security by preventing interception of the authorization code, especially in public clients like mobile or single-page applications.</p>"},{"location":"how-it-works/#server-to-server-communications","title":"Server to server communications","text":"<p>When you have a set of servers working together, and you want to ensure that only the right clients can access resources on a specific server, go for the Client credentials flow, with a confidential client.</p>"},{"location":"how-it-works/#learn-more-about-oauth2","title":"Learn more about OAuth2","text":"<p>OAuth2 covers a lot of ground. To delve deeper into it, check out this link - https://www.oauth.com/</p>"},{"location":"how-it-works/#clients","title":"Clients","text":"<p>A client represents an application that requests access to protected resources.</p> <p>This access can either be on behalf of a user (using the authorization code flow with PKCE) or for the client itself (using the client credentials flow).</p>"},{"location":"how-it-works/#public-or-confidential-clients","title":"Public or confidential clients","text":"<p>Clients can be either public or confidential.</p> <p>A public client is recommended for applications that cannot ensure the confidentiality of their client credentials. This is relevant for JavaScript-only web applications, where any secrets are exposed in the browser, and also in mobile apps, where an APK can be decompiled, revealing stored secrets.</p> <p>A confidential client is recommended for applications that can securely protect client credentials, such as server-side applications. Confidential clients can safely store sensitive information like passwords, as they run on a secure server rather than on a user's device or browser.</p>"},{"location":"how-it-works/#consent-required","title":"Consent required","text":"<p>In OAuth2, the consent process is important for ensuring that users explicitly authorize third-party applications to access their resources.</p> <p>When the client is affiliated with the same organization as the authorization server and a high level of trust exists, explicit consent is not usually required.</p> <p>However, for clients from third-party organizations, it's important to configure the client to request user consent. This ensures that users are aware of who is accessing their tokens.</p>"},{"location":"how-it-works/#default-acr-level","title":"Default ACR level","text":"<p>ACR stands for \"Authentication Context Class Reference.\" It's a way to specify the level of authentication assurance or the strength of the authentication method used to authenticate the end-user.</p> <p>Goiabada has 3 levels:</p> ACR level Description <code>urn:goiabada:level1</code> Level 1 authentication only (password) <code>urn:goiabada:level2_optional</code> Level 1 with optional 2fa (if 2fa is enabled by the user) <code>urn:goiabada:level2_mandatory</code> Level 1 with mandatory 2fa <p>By default, a client comes configured with <code>urn:goiabada:level2_optional</code>.</p> <p>You have the flexibility to override the client's default ACR level on a per-authorization basis. For example, if your client has the default <code>urn:goiabada:level2_optional</code> but you have a specific resource that requires users to authenticate using two-factor authentication (2fa), you can specify <code>urn:goiabada:level2_mandatory</code> in the <code>acr_values</code> parameter of the authorization request.</p>"},{"location":"how-it-works/#redirect-uris","title":"Redirect URIs","text":"<p>In the Authorization code flow with PKCE, the client application specifies a redirect URI in its authorization request.</p> <p>After the user grants or denies permission, the authorization server redirects the user back to this specified URI.</p> <p>It's necessary to pre-configure this URI in the client, and only exact matches are accepted (no wildcards).</p>"},{"location":"how-it-works/#web-origins","title":"Web origins","text":"<p>If your client application plans to make calls to the <code>/token</code>, <code>/logout</code> or <code>/userinfo</code> endpoints from Javascript, you must register the URL (origin) of the web application here, to enable Cross-Origin Resource Sharing (CORS) access. Failure to do so will result in CORS blocking the HTTP requests.</p>"},{"location":"how-it-works/#client-permissions","title":"Client permissions","text":"<p>Client permissions are used in server-to-server checks, specifically within the client credentials flow. This is about the permissions granted to the client itself, allowing it to access other resources.</p>"},{"location":"how-it-works/#resources-and-permissions","title":"Resources and permissions","text":"<p>In Goiabada, you have the ability to define both resources and permissions. Each resource can have multiple permissions associated with it. </p> <p>You can assign these permissions to users, groups, or clients as needed.</p>"},{"location":"how-it-works/#scope","title":"Scope","text":"<p>When you pair a resource with a permission, it forms a scope, both in the authorization request and within the tokens. For example, if you have a resource identified as <code>product-api</code> and a permission identified as <code>delete-product</code> the corresponding scope will be represented as <code>product-api:delete-product</code>.</p>"},{"location":"how-it-works/#openid-connect-scopes","title":"OpenID Connect scopes","text":"<p>Besides the authorization scopes that are formed by resources and permissions (as explained in the previous section), Goiabada supports typical OpenID Connect scopes. They are:</p> OIDC scope Description openid Will include an <code>id_token</code> in the token response, with the subject identifier (<code>sub</code> claim) profile Access to claims: <code>name</code>, <code>family_name</code>, <code>given_name</code>, <code>middle_name</code>, <code>nickname</code>, <code>preferred_username</code>, <code>profile</code>, <code>website</code>, <code>gender</code>, <code>birthdate</code>, <code>zoneinfo</code>, <code>locale</code>, and <code>updated_at</code> email Access to claims: <code>email</code>, <code>email_verified</code> address Access to the <code>address</code> claim phone Access to claims: <code>phone_number</code> and <code>phone_number_verified</code> groups Access to the list of groups the user belongs to attributes Access to the attributes assigned to the user by an admin, stored as key-value pairs offline_access Access to a refresh token of the type <code>Offline</code>, allowing the client to obtain a new access token without requiring an immediate interaction"},{"location":"how-it-works/#user-sessions","title":"User sessions","text":"<p>User sessions facilitate the single sign-on (SSO) functionality of Goiabada. Once a user logs in, a new session starts. If they try to log in again and their session is still good, they don't need to go through the authentication process again.</p> <p>There are two configurations that are related to the user session:</p> Property Description User session idle timeout in seconds If there is no activity from the user within this timeframe, the session will be terminated. This will look into the <code>last_accessed</code> timestamp of the session. User session max lifetime in seconds The maximum duration a user session can last, irrespective of user activity. This will be checked against the <code>started</code> timestamp of the session. <p>A user session is bumped (which means, gets a new <code>last_accessed</code> timestamp) in two situations:</p> <ol> <li>When a new authorization request completes</li> <li>When a refresh token associated with the session is used to request a new access token</li> </ol> <p>In your authorization request, you have the option to include the <code>max_age</code> parameter. This parameter allows you to define the maximum acceptable time (in seconds) since the user's last authentication. For instance, if you add <code>max_age=120</code> to the authentication request, it implies that the user needs to re-authenticate if their last authentication was over 120 seconds (2 minutes) ago, regardless of having a valid session. This is useful when the client needs to ensure that the user authenticated within a specific timeframe.</p>"},{"location":"how-it-works/#token-expiration","title":"Token expiration","text":"<p>You can customize the expiration (in seconds) for access tokens and id tokens on the Settings \u2192 Tokens page. These configurations apply globally to all clients. However, if needed, individual clients have the flexibility to override the global settings in their specific client configurations.</p> <p>The default token expiration is set to 5 minutes. Access tokens are intentionally kept short-lived, for security reasons.</p>"},{"location":"how-it-works/#refresh-tokens","title":"Refresh tokens","text":"<p>Refresh tokens are used in the authorization code flow with PKCE (in the client credentials flow we don't have refresh tokens). </p> <p>Goiabada supports two types of refresh tokens: normal and offline.</p> <p>Normal tokens are linked to the user session. They can be used to get a new access token, as long as there's an active user session. When a normal refresh token is used, the user session <code>last_accessed</code> timestamp is bumped. The expiration time of a normal refresh token is the same as the user session idle timeout (default is 2 hours). If the user session is terminated,  it will automatically invalidate the refresh tokens linked to that session.</p> <p>Offline refresh tokens are not linked to a user session. They can be used to obtain a new access token even when the user is not actively using the application. Their expiration time is long (defaults to 30 days).</p> <p>In your authorization request, when you ask for the <code>offline_access</code> scope, your refresh token will be classified as <code>offline</code>. Otherwise, if you don't include the <code>offline_access</code> scope, your refresh token will be considered normal.</p> <p>Upon each usage of a refresh token, the refresh token passed in to the <code>/auth/token</code> endpoint becomes inactive, and a new refresh token is provided in the token response. In other words, a refresh token is a one-time-use token; once used, it must be substituted with the new refresh token obtained from the response.</p>"},{"location":"how-it-works/#users-and-groups","title":"Users and groups","text":"<p>As an administrator of Goiabada you can create users and configure their properties (profile information, address, phone, email...). Also, you have the capability to modify their credentials, terminate active user sessions, and revoke consents.</p> <p>You can also assign permissions and attributes to individual users. Attributes are key-value pairs or arbitraty information, and can be included in the access token or id token.</p> <p>To facilitate user management, you can create groups of users. When you give a permission to a group, it's given to all group members. The same applies to attributes - group attributes will be included for all group members.</p> <p>Attributes are arbitrary key-value pairs that you can associate with either a user or a group. When creating an attribute, you can choose to include it either in the access token or the id token.</p>"},{"location":"how-it-works/#self-registration","title":"Self registration","text":"<p>When the 'Self registration' setting is activated, users gain the ability to independently register their accounts using a link incorporated into the login form. If this setting is disabled, only administrators have the privilege of creating new user accounts.</p> <p>For self-registrations, there's an option to require email verification for new users. Enabling this ensures that an account only becomes active after the user clicks a verification link sent to their email. To use this feature, be sure to configure your SMTP settings.</p>"},{"location":"how-it-works/#endpoints","title":"Endpoints","text":""},{"location":"how-it-works/#well-known-discovery-url","title":"Well-known discovery URL","text":"<p>You can find a link to the well-known discovery URL by going to the root of the admin console. The URL will look like this:</p> <p><code>https://demo-authserver.goiabada.dev/.well-known/openid-configuration</code></p> <p>This endpoint will show the capabilities that are supported by Goiabada.</p>"},{"location":"how-it-works/#authauthorize-get","title":"/auth/authorize (GET)","text":"<p>The authorize endpoint is used to request authorization codes via the browser. This process normally involves authentication of the end-user and giving consent, when required.</p> <p>Parameters (* are mandatory):</p> Parameter Description client_id The client identifier. redirect_uri The redirect URI is the callback entry point of the app. In other words, it's the location where the authorization server sends the user once the <code>/auth/authorize</code> process completes. This must exactly match one of the allowed redirect URIs for the client. response_type <code>code</code> is the only value supported - for the authorization code flow with PKCE. code_challenge_method <code>S256</code> is the only value supported - for a SHA256 hash of the code verifier. code_challenge A random string between 43 and 128 characters long. response_mode Supported values: <code>query</code>, <code>fragment</code> or <code>form_post</code>. With <code>query</code> the authorization response parameters are encoded in the query string of the <code>redirect_uri</code>. With <code>fragment</code> they are encoded in the fragment (#). And <code>form_post</code> will make the parameters be encoded as HTML form values that are auto-submitted in the browser, via HTTP POST. max_age If the user's authentication timestamp exceeds the max age (in seconds), they will have to re-authenticate acr_values Supported values are: <code>urn:goiabada:pwd</code>, <code>urn:goiabada:pwd:otp_ifpossible</code> or <code>urn:goiabada:pwd:otp_mandatory</code>. This will override the default ACR level configured in the client for this authorization request. See Default ACR level. state Any string. Goiabada will echo back the state value on the token response, for CSRF/replay protection. nonce Any string. Goiabada will echo back the nonce value in the identity token, as a claim, for replay protection. scope One or more registered scopes, separated by a space character. A registered scope can be either a <code>resource:permission</code> or an OIDC scope. See Scope and OpenID Connect scopes."},{"location":"how-it-works/#authtoken-post","title":"/auth/token (POST)","text":"<p>The token endpoint serves the purpose of requesting tokens. This can happen either through the authorization code flow, involving the exchange of an authorization code for tokens, or through the client credentials flow, where a client directly requests tokens.</p> <p>Parameters:</p> Parameter Description grant_type Supported grant types are <code>authorization_code</code> (to exchange an authorization code for tokens), <code>client_credentials</code> (for the client credentials flow) or <code>refresh_token</code> (to use a refresh token). client_id The client identifier. client_secret The client secret, if it's a confidential client. redirect_uri Required for the <code>authorization_code</code> grant type. code The authorization code. Required for the <code>authorization_code</code> grant type. code_verifier This is the code verifier associated with the PKCE request, initially generated by the app before the authorization request. It represents the original string from which the <code>code_challenge</code> was derived. scope This parameter is used in the <code>client_credentials</code> and <code>refresh_token</code> grant types. In <code>client_credentials</code> grant type, it's a mandatory parameter, and it should encompass one or more registered scopes, separated by a space character. These scopes represent the requested permissions in the format of <code>resource:permission</code>. For the <code>refresh_token</code> grant type, the scope parameter is optional and serves to restrict the original scope to a more specific and narrower subset. refresh_token The refresh token, required for the <code>refresh_token</code> grant type."},{"location":"how-it-works/#authlogout-get-or-post","title":"/auth/logout (GET or POST)","text":"<p>This endpoint enables the client application to initiate a logout. The client application calls this logout endpoint on the auth server. Upon successful logout from the auth server, the user agent is then redirected to a logout link within the client application. This implementation aligns with the OpenID Connect RP-Initiated Logout 1.0 protocol.</p> <p>If the <code>/auth/logout</code> endpoint is invoked without parameters, it will display a logout consent screen, prompting the user to confirm their intention to log out. There will be no redirection to the client application in this scenario.</p> <p>The recommended way of calling <code>/auth/logout</code> involves including additional parameters:</p> Parameter Description id_token_hint The previously issued id token. post_logout_redirect_uri A post-logout URI, which must be pre-registered with the client as a redirect URI. Once the logout is finalized on the authentication server, the user agent will be redirected to this post-logout URI. This allows for the termination of the session on the client application as well. client_id The client identifier. Mandatory if the <code>id_token_hint</code> parameter is encrypted with the client secret. state Any arbitraty string that will be echoed back in the <code>post_logout_redirect_uri</code>. <p>The two possible routes are:</p> <ol> <li><code>id_token_hint</code> (unencrypted) + <code>post_logout_redirect_uri</code> + <code>state</code> (optional).  </li> <li><code>id_token_hint</code> (encrypted with AES GCM) + <code>post_logout_redirect_uri</code> + <code>client_id</code> + <code>state</code> (optional).  </li> </ol> <p>Encrypting the <code>id_token_hint</code> (option 2) enhances security by preventing the exposure of the ID token on the client side. Without encryption, calling this endpoint with an unencrypted <code>id_token_hint</code> could potentially expose personally identifiable information (PII) and other claims that are inside of the id token, such as the client identifier.</p> <p>Below are some examples on how to encrypt the id token for the <code>id_token_hint</code> parameter. You must URL-encode the resulting base64 string, when sending it as a querystring parameter to <code>/auth/logout</code>.</p>"},{"location":"how-it-works/#net-c","title":".NET C#","text":"<pre><code>private static string AesGcmEncryption(string idTokenUnencrypted, \n    string clientSecret)\n{\n    var key = new byte[32];\n\n    // use the first 32 bytes of the client secret as key\n    var keyBytes = Encoding.UTF8.GetBytes(clientSecret);\n    Array.Copy(keyBytes, key, Math.Min(keyBytes.Length, key.Length));\n\n    // random nonce\n    var nonce = new byte[AesGcm.NonceByteSizes.MaxSize]; // MaxSize = 12\n    RandomNumberGenerator.Fill(nonce);\n\n    using var aes = new AesGcm(key);\n    var cipherText = new byte[idTokenUnencrypted.Length];\n    var tag = new byte[AesGcm.TagByteSizes.MaxSize]; // MaxSize = 16\n    aes.Encrypt(nonce, Encoding.UTF8.GetBytes(idTokenUnencrypted), \n        cipherText, tag);\n\n    // concatenate nonce (12 bytes) + ciphertext (? bytes) + tag (16 bytes)\n    var encrypted = new byte[nonce.Length + cipherText.Length + tag.Length];\n    Array.Copy(nonce, encrypted, nonce.Length);\n    Array.Copy(cipherText, 0, encrypted, nonce.Length, cipherText.Length);\n    Array.Copy(tag, 0, encrypted, nonce.Length + cipherText.Length, tag.Length);\n\n    return Convert.ToBase64String(encrypted);\n}\n</code></pre>"},{"location":"how-it-works/#go","title":"Go","text":"<pre><code>import (\n    \"crypto/aes\"\n    \"crypto/cipher\"\n    \"crypto/rand\"\n    \"encoding/base64\"\n    \"io\"\n    \"math\"\n)\n\nfunc AesGcmEncryption(idTokenUnencrypted string, clientSecret string) (string, error) {\n    key := make([]byte, 32)\n\n    // Use the first 32 bytes of the client secret as key\n    keyBytes := []byte(clientSecret)\n    copy(key, keyBytes[:int(math.Min(float64(len(keyBytes)), float64(len(key))))])\n\n    // Random nonce\n    nonce := make([]byte, 12)\n    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {\n        return \"\", err\n    }\n\n    block, err := aes.NewCipher(key)\n    if err != nil {\n        return \"\", err\n    }\n\n    aesGcm, err := cipher.NewGCM(block)\n    if err != nil {\n        return \"\", err\n    }\n\n    cipherText := aesGcm.Seal(nil, nonce, []byte(idTokenUnencrypted), nil)\n\n    // Concatenate nonce (12 bytes) + ciphertext (? bytes) + tag (16 bytes)\n    encrypted := make([]byte, len(nonce)+len(cipherText))\n    copy(encrypted, nonce)\n    copy(encrypted[len(nonce):], cipherText)\n\n    return base64.StdEncoding.EncodeToString(encrypted), nil\n}\n</code></pre>"},{"location":"how-it-works/#nodejs","title":"NodeJS","text":"<pre><code>const crypto = require('crypto');\n\nfunction aesGcmEncryption(idTokenUnencrypted, clientSecret) {\n    const key = Buffer.alloc(32);\n\n    // Use the first 32 bytes of the client secret as the key\n    const keyBytes = Buffer.from(clientSecret, 'utf-8');\n    keyBytes.copy(key, 0, 0, Math.min(keyBytes.length, key.length));\n\n    // Random nonce\n    const nonce = crypto.randomBytes(12);\n\n    const cipher = crypto.createCipheriv('aes-256-gcm', key, nonce);\n    let cipherText = cipher.update(idTokenUnencrypted, 'utf-8', 'base64');\n    cipherText += cipher.final('base64');\n\n    const tag = cipher.getAuthTag();\n\n    // Concatenate nonce (12 bytes) + ciphertext (? bytes) + tag (16 bytes)\n    const encrypted = Buffer.concat([nonce, Buffer.from(cipherText, 'base64'), tag]);\n\n    return encrypted.toString('base64');\n}\n</code></pre> <p>You can explore the libraries available on your platform and use the same approach as shown here.</p>"},{"location":"how-it-works/#userinfo-get-or-post","title":"/userinfo (GET or POST)","text":"<p>The UserInfo endpoint, a component of OpenID Connect, is used to retrieve identity information about a user.</p> <p>The caller needs to send a valid access token to be able to access this endpoint. This is done by adding the <code>Authorization: Bearer token-value</code> header to the HTTP request.</p> <p>The endpoint validates the presence of the <code>authserver:userinfo</code> scope within the access token. If this scope is present, the endpoint responds by providing claims about the user. </p> <p>Please note that you don't need to manually request the <code>authserver:userinfo</code> scope in the authorization request. Instead, it will be automatically included in the access token whenever any OpenID Connect scope is included in the request.</p> <p>The specific claims returned by the UserInfo endpoint depend on the OpenID Connect scopes included in the access token. For instance, if the <code>openid</code> and <code>email</code> scopes are present, the endpoint will return the <code>sub</code> (subject) claim from the <code>openid</code> scope, as well as the <code>email</code> and <code>email_verified</code> claims from the email scope.</p>"},{"location":"integration/","title":"Integration","text":"<p>To integrate Goiabada with your app, you'll need to explore your platform for an OAuth2/OpenID Connect client library. Most of platforms provide such libraries for integration.</p>"},{"location":"integration/#javascript-only","title":"Javascript-only","text":"<p>The github repository of Goiabada has a browser-based javascript test client that you can use to test Goiabada. It uses the oauth4webapi library.</p>"},{"location":"integration/#go-web-app","title":"Go web app","text":"<p>We also have a sample integration using Go. Have a look here.</p>"},{"location":"integration/#react-spa-with-vite-and-nodejs-server","title":"React SPA with Vite and NodeJS server","text":"<p>Take a look at this sample react application that uses authentication and role (group) based authorization, with token auto-refresh.</p>"},{"location":"license/","title":"License","text":""},{"location":"license/#intro","title":"Intro","text":"<p>Goiabada is open source and 100% free of charge. You can do whatever you want with the software, as long as you read and agree with the full MIT license text below.</p> <p>Use Goiabada at your own risk. We don't provide any warranty or guarantee of any kind. We're also not responsible for any damage or loss caused by the software.</p>"},{"location":"license/#full-license-text","title":"Full license text","text":"<pre><code>MIT License\n\nCopyright (c) 2023 Leonardo D'Ippolito (contact@leodip.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"security/","title":"Security","text":"<p>Security is a top priority. If you discover a security issue, please report it via contact@leodip.com.</p> <p>We're very thankful to Adrean Boyadzhiev from Lambda Bit, who provided a security assessment and consultancy for Goiabada. Adrean's work focused on an earlier version (0.0.3), and while much has changed since, his insights were invaluable. </p> <p>If you're looking for a security expert, we recommend reaching out to Adrean.</p>"}]}