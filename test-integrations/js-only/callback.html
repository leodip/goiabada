<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OAuth2 test client - js only</title>

  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <div class="title-panel">
    <h1>Authorization code + PKCE flow (javascript only)</h1>
    <h2>Callback page</h2>
  </div>
  <div class="parent">
    <div class="left-panel">
      <form action="" id="form">
        <div class="field">
          <label for="tokenEndpoint">Token endpoint</label>
          <input type="text" id="tokenEndpoint" name="tokenEndpoint" value="" />
        </div>

        <div class="field">
          <label for="client_id">Client id</label>
          <input type="text" id="client_id" name="client_id" value="" />
        </div>

        <div class="field">
          <label for="redirect_uri">Redirect uri</label>
          <input type="text" id="redirect_uri" name="redirect_uri" value="" />
        </div>

        <div class="field">
          <input onclick="exchangeCode(this, event);" id="exchangeCodeBtn" type="submit" value="3. Exchange code" disabled>
          <input onclick="refreshToken(this, event);" id="refreshTokenBtn" type="submit" value="4. Refresh token" disabled>
          <input onclick="getUserInfo(this, event);" id="userInfoBtn" type="submit" value="Get userinfo" disabled>
          <a href="/index.html">Restart</a>
        </div>
      </form>
    </div>
    <div class="right-panel">
      <div id="log"></div>
    </div>
  </div>

  <script type="module">
    import * as oauth2 from 'https://cdn.jsdelivr.net/npm/oauth4webapi@3.8.4/+esm'
    import { decodeJwt } from 'https://cdn.jsdelivr.net/npm/jose@6.1.3/+esm'
    import { log, logJson, logError } from './utils.js'

    var authorizationServer = null;
    var client = null;
    var params = null;
    var nonce = null;
    var max_age = null;
    var redirect_uri = null;
    var code_verifier = null;
    var currentRefreshToken = null;
    var currentAccessToken = null;
    var currentSub = null;

    // Initialize on page load
    const client_id = localStorage.getItem("client_id");
    if (client_id) {
      document.getElementById("client_id").value = client_id;
    }

    redirect_uri = localStorage.getItem("redirect_uri");
    if (redirect_uri) {
      document.getElementById("redirect_uri").value = redirect_uri;
    }

    const issuer = localStorage.getItem("issuer");
    const state = localStorage.getItem("state");
    nonce = localStorage.getItem("nonce");
    max_age = localStorage.getItem("max_age");
    code_verifier = localStorage.getItem("code_verifier");

    try {
      authorizationServer = await oauth2
        .discoveryRequest(new URL(issuer), { [oauth2.allowInsecureRequests]: true })
        .then((response) => {
          let as = oauth2.processDiscoveryResponse(new URL(issuer), response);
          return as;
        });
    }
    catch (error) {
      logError(error);
    }

    if (authorizationServer) {
      document.getElementById("tokenEndpoint").value = authorizationServer.token_endpoint;

      client = {
        client_id: document.getElementById("client_id").value,
        token_endpoint_auth_method: "none",
      };

      params = null;
      try {
        let source = window.location.search;
        const response_mode = localStorage.getItem("response_mode");
        if (response_mode == "fragment") {
          source = "?" + window.location.hash.substring(1);
        }

        params = oauth2.validateAuthResponse(authorizationServer, client, new URLSearchParams(source), state)
      }
      catch (exc) {
        logError(exc);
      }

      if (params) {
        log("Auth response validated successfully.", "blue");
        log("code: " + params.get("code"));
        log("state: " + params.get("state"));

        log("&larr; Click 'Exchange code' to get tokens", "blue");

        document.getElementById("exchangeCodeBtn").disabled = false;
      }
    }

    async function exchangeCode(elem, evt) {
      evt.preventDefault();

      let nonceParam = null;
      let maxAgeParam = null;

      if (nonce && nonce.length > 0) {
        nonceParam = nonce;
        log("nonce: " + nonceParam);
      }

      if (max_age && max_age.length > 0) {
        maxAgeParam = parseInt(max_age);
        log("max_age: " + maxAgeParam);
      }

      log("Exchanging code for tokens...", "blue");

      let response = null;
      let responseClone = null;

      const clientAuth = oauth2.None()

      try {
        response = await oauth2.authorizationCodeGrantRequest(
          authorizationServer,
          client,
          clientAuth,
          params,
          redirect_uri,
          code_verifier,
          { [oauth2.allowInsecureRequests]: true }
        );
        responseClone = response.clone();

        let noIdToken = false;
        let result = null;

        try {
          result = await oauth2.processAuthorizationCodeResponse(
            authorizationServer,
            client,
            response,
            {
              expectedNonce: nonceParam,
              maxAge: maxAgeParam,
              requireIdToken: true
            }
          );
        } catch (exc) {
          if (exc instanceof oauth2.OperationProcessingError && exc.message.includes('"id_token" property must be a string')) {
            noIdToken = true;
          } else {
            logError(exc);
            return;
          }
        }

        if(noIdToken) {
          try {
            result = await oauth2.processAuthorizationCodeResponse(
              authorizationServer,
              client,
              responseClone
            );
          } catch (exc) {
            logError(exc);
            return;
          }
        }

        log("Code exchanged successfully.", "blue");

        logJson(result);

        if (result.access_token) {
          log("Decoded access_token:", "blue");
          var decodedAccessToken = decodeJwt(result.access_token);
          logJson(decodedAccessToken);

          // Store access token and enable userinfo button
          currentAccessToken = result.access_token;
          currentSub = decodedAccessToken.sub;
          document.getElementById("userInfoBtn").disabled = false;
        }

        if (result.id_token) {
          log("Decoded id_token:", "blue");
          var decodedIdToken = decodeJwt(result.id_token);
          logJson(decodedIdToken);

          // Use sub from id_token if available (more reliable)
          currentSub = decodedIdToken.sub;
        }

        if (result.refresh_token) {
          log("Decoded refresh_token:", "blue");
          var decodedRefreshToken = decodeJwt(result.refresh_token);
          logJson(decodedRefreshToken);

          // Store refresh token and enable refresh button
          currentRefreshToken = result.refresh_token;
          document.getElementById("refreshTokenBtn").disabled = false;
        }

        log("Done.", "blue");
        document.getElementById("exchangeCodeBtn").disabled = true;

      } catch (error) {
        logError(error);
        return;
      }
    }

    async function refreshToken(elem, evt) {
      evt.preventDefault();

      if (!currentRefreshToken) {
        logError({ message: "No refresh token available" });
        return;
      }

      log("Refreshing tokens...", "blue");

      const clientAuth = oauth2.None();

      try {
        const response = await oauth2.refreshTokenGrantRequest(
          authorizationServer,
          client,
          clientAuth,
          currentRefreshToken,
          { [oauth2.allowInsecureRequests]: true }
        );

        const result = await oauth2.processRefreshTokenResponse(
          authorizationServer,
          client,
          response
        );

        log("Tokens refreshed successfully.", "blue");

        logJson(result);

        if (result.access_token) {
          log("Decoded access_token:", "blue");
          var decodedAccessToken = decodeJwt(result.access_token);
          logJson(decodedAccessToken);

          // Update stored access token
          currentAccessToken = result.access_token;
          currentSub = decodedAccessToken.sub;
        }

        if (result.id_token) {
          log("Decoded id_token:", "blue");
          var decodedIdToken = decodeJwt(result.id_token);
          logJson(decodedIdToken);

          // Use sub from id_token if available (more reliable)
          currentSub = decodedIdToken.sub;
        }

        if (result.refresh_token) {
          log("Decoded refresh_token:", "blue");
          var decodedRefreshToken = decodeJwt(result.refresh_token);
          logJson(decodedRefreshToken);

          // Update stored refresh token (rotation)
          currentRefreshToken = result.refresh_token;
          log("Refresh token updated (rotation).", "blue");
        }

        log("Done.", "blue");

      } catch (error) {
        logError(error);
        return;
      }
    }

    async function getUserInfo(elem, evt) {
      evt.preventDefault();

      if (!currentAccessToken) {
        logError({ message: "No access token available" });
        return;
      }

      if (!currentSub) {
        logError({ message: "No subject (sub) available" });
        return;
      }

      log("Getting userinfo...", "blue");

      try {
        const userInfoResponse = await oauth2.userInfoRequest(
          authorizationServer,
          client,
          currentAccessToken,
          { [oauth2.allowInsecureRequests]: true }
        );

        const userInfoResult = await oauth2.processUserInfoResponse(
          authorizationServer,
          client,
          currentSub,
          userInfoResponse
        );

        log("Userinfo retrieved successfully.", "blue");
        logJson(userInfoResult);

      } catch (error) {
        logError(error);
        return;
      }
    }

    // Expose functions to window for onclick handlers
    window.exchangeCode = exchangeCode;
    window.refreshToken = refreshToken;
    window.getUserInfo = getUserInfo;
  </script>
</body>

</html>
